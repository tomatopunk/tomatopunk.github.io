---
title: 诊断性能问题的工作流程(0)
date: 2020-11-07 14:27:26
update: 2020-11-13 14:27:26
categories: C#
tags:
    - C#
    - 性能诊断
    - Maoni
    - PerfView
---
原文为Maoni发布在Microfost Blog中的,诊断性能问题的工作流程系列.
目前共更新三章.在本章中,Maoni介绍了一些关于GC设计与工具的使用,如果您已经具备了诊断性能问题的经验,可以直接跳过本章.
<!-- more -->

### 原文信息

[@Maoni Stephens-Twitter](https://twitter.com/maoni0)
[@Maoni Stephens-Github](https://github.com/Maoni0)

![authorize](/img/1587561145552-0d8a560c-3b7d-443a-badc-a98ddbb6e7bf.png)

如果这篇文章可以帮到您，那么这将是我最大的荣幸，希望您点进原文，在文章下方留下善意的回复，您的支持将是这些可敬的社区磐石保持创作激情中最大的一部分:)

[原文](https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-1)

**中文版本将不会以任何形式收费，版权属与原作者**

---

我想描述一下我是怎样诊断内存中的性能问题的,或者更确切的说是在进行此类诊断的各种工作流程中常见的部分.诊断性能问题可以采用很多方式,因为没有固定的步骤,但是我将尝试一下分解成可用于进行各种诊断一些基本的模块.

这一部分是针对于初学者的,所以如果您已经进行了一段时间的内存性能问题,您可以安全的跳过这一章节.

首先,在我们开始讨论实际的诊断部分之前,了解一下高级的东西会非常有用,它们会帮您指明正确的方向.

1)时间点 vs 时间段

了解性能问题往往不是点状点,这一点非常重要.内存问题通常不会突然出现,可能需要一段时间才能积累到引人注目到程度.

让我们举一个简单的例子,对于一个非常简单的没有世代的GC,它只会紧凑的进行中断式GC.这种情况会一只存在.如果您刚结束了GC,堆当然处在最小的点.如果您碰巧在这个点进行测量,您会认为“太好了;我的堆很小”.但如果您恰好在进行下一次GC之前测量,则堆可能会大得多,并且您会有一些不同的看法.这只是针对于一个简单堆GC.想象一下当您有一个世代GC,或者并发式GC时,会发生些什么.

这就是为什么了解一下GC的(历史,history??? > 再看看)是及其重要的,看看GC是如何作出的决策,以及这些决策是如何导致目前的情况.

遗憾的是,很多内存工具或诊断方法,都没有将其考虑在内,它们进行内存诊断都方式是“让我来告诉您,您碰巧问到的那个时间点,堆上的情况”.这往往无济于事,有时候甚至会完全误导人们.浪费时间去追寻一个不存在的问题或者在一个完全错误的问题上取得一些完全错误的进展.这并不是说此类工具一点用处都没有-当问题很简单时,它们可能会有所帮助.如果您有一个非常严重的的内存泄漏,并且已经持续了一段时间,而您使用一个工具来显示这个当前的堆(采取进程转储或使用sos,或者另外的一些堆转储的工具),可能真的会很明显的显示出泄漏的是什么.

2)世代GC

从设计上来看,具有世代的GC并不会每次触发时收集整个堆.尝试对年轻代的GC频率要比对老年代GC高得多,因为对老年代GC的成本往往要高得多.对于并发的老年代GC来说,STW的的中断时间不会很长,但仍然会需要花费CPU时钟来完成GC的工作.

这也使查看堆变得更加复杂,因为如果您刚完成一个老年代的GC,特别是刚经历过压缩的GC,您的堆显然可能会比在该GC被触发之前的堆要小的多.但如果您查看年轻代的GC,它们可能正在压缩,但是区别在于堆大小可能没有那么大堆变化,这是设计使然.

3)压缩 vs 回收

回收不应该过多的改变堆的大小.在我们的实现中,我们仍然会放弃堆末尾的空间,所以整体的堆大小可能会变小,但总的来说,您可以认为整体的堆大小并没有发生改变,但是为了容纳年轻代堆分配(或者用户分配在零代/LOH的情况下),会建立起自由空间(free spaces).

因此,如果您看到gen2的两次gc,一次正在压缩而另一次正在回收.那么可以预计,压缩结束后,堆大小会缩小很多.而另一个的碎片化程度会很高(在设计中,我们会创建自由列表(free list)).

4)分配 vs 存活

虽然很多内存工具都会报告分配情况,但是GC的成本不仅仅是来自分配.当然分配会触发GC,这无疑是成本.但当GC工作时,成本主要取决于存活.当然,您不能同时处于分配率和存活率都很高的情况,这样只会非常快的用光内存.

5)“主线GC方案 vs 非主线”

如果您的程序仅仅是使用堆栈并且创建了一些要使用的对象,GC多年来一只在优化.基本上就是“扫描堆栈得到根对象然后在那里处理对象”.这就是许多GC论文都将其视为唯一的方案的主线GC方案.当然作为一个存在了几十年的商业产品,为了适应客户的各种需求,我们还有一些其他的例如GC句柄和终结器的东西.

有一个很重要的事情请您理解,尽管多年来我们对这些进行了优化,但我们都是基于“没有太多的这些东西”进行的假设,这显然不会适用于每个人.所以如果您确实使用了很多这些东西,在诊断内存问题时值得一看.换句话说,如果您没有内存问题,则无需在意;但是如果您有(例如GC的百分比时间很高),它们是很好的怀疑对象.

所有的这些信息都表示为ETW事件或在Linux上的等效事件-这就是为什么我们多年来投资于分析跟踪的工具的原因.

要捕捉的跟踪开始于

我通常会从两条跟踪开始.第一次是为了获取准确的GC时间:

**perfview /GCCollectOnly /nogui collect**

完成后,在PerfView的cmd窗口按s停止.

这应该运行足够长的时间,来捕获足够的GC活动,例如,如果您知道问题何时会发生,则应该涵盖导致问题发生的时间(不仅仅只有发生问题的时间).

如果您知道要运行多长时间,您可以这样做(这实际上是更常用的) -

**perfview /GCCollectOnly /nogui /MaxCollectSec:1800 collect**

将1800(半小时)替换成您需要的秒数

这将收集infomational级别的GC事件和足够的OS事件,以及解码后的进程名称.这个命令非常轻量,所以它可以一只保持运行.

请注意,我给出的所有PerfView命令都有/nogui.PerfView确实有一个用于事件收集的UI,可以让您选择需要捕获的事件.但就我而言,我从没使用过它(除了在我刚刚使用PerfView的时候使用了几次).一部分原因是因为我更喜欢命令行;另一部分(更重要的)原因是命令行具有更多的灵活性,对自动化很友好.

当您搜集到跟踪数据后,您可以使用PerfView打开它并查看GCStats视图,有些人倾向于在完成收集后将其发送给我,但我真的鼓励每个需要定期进行内存诊断的人学习阅读这个视图,因为它非常有用.尽管是如此轻量级的跟踪,但仍旧给我们提供了大量的信息.并且就算不能让我们找到根本原因,也会指出取得更大进展的方向.我在[这篇文章](https://devblogs.microsoft.com/dotnet/gc-etw-events-1/)及续篇描述了这些视图,在文章中都有链接.所以我在这里不打算展示更多的图片.您可以自己很轻易的打开这些视图.

通过此视图很容易发现的问题类型的例子-

- 非常高的“% Time paused for garbage collection(垃圾收集的中断时间百分比)”.除非您正在做一些基准测试,特别是在测试分配性能(类似非常多GC的基准测试),这个不指标不应该高于百分之几.如果您已经发现很高了,那就需要调查了.下面是一些会显著导致这个百分比增加的事情.

- 个别GC的中断事件特别长.60s的GC很长吗?是的,肯定很长!这通常来说不是由于GC的工作导致的.根据我的经验,这往往是由于某些因素干扰了GC线程.

- 过多的主动引起的GC(主动引发的GC/触发GC的总数量 比例很高时),特别是主动引发的GC的目标代是第二代时.
  
- 过多的针对二代堆GC - 对二代堆进行GC是十分昂贵的,尤其是当您有一个大堆时.即便使用了GBC,大部分工作都是并发完成的.但它仍需要花费CPU周期,因此,如果您其他的GC都是针对第二代,这通常是指出了一个问题,一种明显的情况是它们的大部分的触发理由都是AllocLarge.同样,在某些情况下,这不一定是问题,例如,如果您的堆大部分都是LOH,并且没有在容器中运行,这意味着LOH默认不会进行压缩,在这种情况下,进行二代堆堆GC只会回收并快速的退出.

- 长时间的挂起问题-挂起通常应该远远小于1ms,如果需要10ms,那就是问题,如果需要上百毫秒,那毫无疑问是问题.

- 过多的固定句柄 - 一般情况下,少量的几个固定句柄是可以的,但如果您在短暂的GC中看到数百个,那就值得关注了;如果您看到几千个,通常,这是告诉您需要调查了.

这些只是您第一眼就能看到的东西.如果您要进行更加深入的挖掘,还有很多事情要做.我们下次在讨论.
---
title: CLR线程概述
date: 2020-11-10 14:27:26
update: 2020-11-13 14:27:26
categories: C#
tags:
    - C#
    - 性能诊断
    - 线程
    - 概要设计
    - CLR Thread
    - Thread
---
**CLR线程的概要设计**
### 原文信息
[原文:dotnet/coreclr](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/threading.md)
<!-- more -->

### 托管线程 vs 原生线程

托管代码执行在“托管线程上”,“托管线程”与操作系统提供的原生线程不同,原生线程是在物理机上执行原生代码的线程.托管代码是在CLR虚拟机执行的虚拟线程.

就像JIT编译器将“虚拟”IL指令映射到原生指令在物理机上执行一样,CLR的线程**infrastructure**将“虚拟”的托管线程映射到操作系统的原生线程上.

在任何时候,一个托管线程可能会分配给一个原生线程来执行,也可能不会.例如一个已经创建(通过“new System.Threading.Thread”)但是尚未启动(通过System.Threading.Thread.Start)的托管线程没有分配任何的原生线程.同样,一个托管线程也可能在执行过程中在多个的原生线程之间移动,尽管实际上CLR目前不支持此操作.

托管代码可使用公共线程接口有意隐藏了底层原生线程的细节,因为

- 托管线程不一定会映射到单个原生线程(也可能根本没有映射到原生线程上)
- 不同到操作系统提供了不同的原生线程的抽象.
- 原则上,托管线程是”虚拟的“.

CLR提供了同样的托管线程的抽象,由CLR本身自己实现.例如,它没有公开操作系统的线程本地存储(TLS)机制.而是提供了托管的“静态线程(thread-static)”变量.同样,它没有暴露原生线程的“线程ID”,而是提供了独立于OS的“托管线程ID”.然而,出于诊断的目的,可以通过System.Diagnostics命名空间下的类型获取原生线程的一些底层细节.

托管线程需要一些原生线程不需要的拓展功能.首先,托管线程将GC的引用保存在栈上,所以CLR必须能够每次发生GC时枚举(或是修改)这些引用.要做到这个,CLR必须“挂起(suspend)”每一个托管线程(在可以找到其所有的GC引用的地方停止它).其次,当AppDomain卸载时.CLR必须确保没有线程在该AppDomain中执行代码.这就需要能够让线程强制从该AppDomain中回退出来.CLR通过向这些线程注入ThreadAbortException来实现它.

### 数据结构

每一个托管线程都有关联的Thread对象,在threads.h中定义.该对象跟踪虚拟机需要知道的关于托管线程的一切信息.这包括了一些必要的东西,当前的GC模式和栈帧(Frame chain(帧链,调用链?)),以及许多出于性能原因而按线程分配的东西( **~比如快速的区域分配风格/ fast arena-style allocators**).

---
layout: post
title: è¯Šæ–­æ€§èƒ½é—®é¢˜çš„å·¥ä½œæµç¨‹ â€“ Part 2ï¼ˆç¿»è¯‘è®¡åˆ’ä¸­ï¼‰
date: 2020-05-06 22:06 +0800
---

Creater:        [@Maoni Stephens](https://twitter.com/maoni0)

Translator:     @Shaun Murphy

Proofreaderï¼šå¾…å®š

> [åŸæ–‡é“¾æ¥](https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-0)

---
# ä½œè€…æˆæƒ

![authorize]({{ site.baseurl }}/images/1587561145552-0d8a560c-3b7d-443a-badc-a98ddbb6e7bf.png)

> æœªç»åŸä½œè€…å…è®¸ä»¥åŠä¿æŠ¤éšç§ï¼Œè¿™é‡Œå°†maoniå¤§ä½¬çš„é‚®ç®±åœ°å€éšå»äº†ï¼Œå¦‚æœæƒ³è¦ä¸åŸä½œè€…å–å¾—è”ç³»ï¼Œè¯·åœ¨åŸæ–‡çš„ä¸‹æ–¹è¿›è¡Œç•™è¨€ã€‚

## è¯‘è€…æŒ‰

å¦‚æœè¿™ç¯‡æ–‡ç« å¯ä»¥å¸®åˆ°æ‚¨ï¼Œé‚£ä¹ˆè¿™å°†æ˜¯æˆ‘æœ€å¤§çš„ä¸€ä»½è£å¹¸ï¼Œä½†ä¹Ÿè¯·æ‚¨ç‚¹è¿›åŸæ–‡ï¼Œç»™åŸä½œè€…ä¸€ä¸ªå–„æ„çš„å›å¤ï¼Œæˆ–åœ¨æ–‡ç« ä¸‹æ–¹ç•™ä¸‹å–„æ„çš„å›å¤ï¼Œæ‚¨çš„æ”¯æŒå°†æ˜¯è¿™äº›å¯æ•¬çš„ç¤¾åŒºç£çŸ³ä¿æŒåˆ›ä½œæ¿€æƒ…ä¸­æœ€å¤§çš„ä¸€éƒ¨åˆ†:)

<b>ä¸­æ–‡ç‰ˆæœ¬å°†ä¸ä¼šä»¥ä»»ä½•å½¢å¼æ”¶è´¹ï¼Œæ‰€æœ‰ç‰ˆæƒå½’å±ä¸åŸä½œè€…</b>

åŸä½œè€…Twitterï¼š[https://twitter.com/maoni0](https://twitter.com/maoni0)

åŸä½œè€…Githubï¼š[https://github.com/Maoni0](https://github.com/Maoni0)

---
## æ­£æ–‡

In this blog post Iâ€™ll talk a bit about how to spend time wisely and then continue with the analysis. Originally I was going to delve deeper into the GCStats view but I actually just debugged a long suspension issue that I wanted to share 'cause it shows some general ideas of what to do when you hit problems during an analysis. You can skip to the analysis part directly if you like.

PerfView isnâ€™t just to collect traces. More importantly, itâ€™s to analyze traces. Iâ€™ve come across folks again and again where they collected a trace and thatâ€™s the end of usage of PerfView. I would really strongly encourage you to actually use it also as an analysis tool. Thereâ€™s already an extensive help built in in PerfView. Obviously the main reason why Iâ€™m writing this blog series is to also help you with that but with more focus on the memory side. I try to explain why I do things the way I do â€“ the end goal is to help you to get ideas of approaches on how to figure out perf problems; not to list exhaustively all the problems you might hit which would be completely unrealistic.

My philosophy is always that you should be wise about what you spend your time on. We are all very busy with endless tasks to do. I also get that many of us are very independent people and love to figure things out on our own. So how much work do you do on your own before you ask someone for help? These are a couple of rules I go by â€“

- be generous about spending time to acquire knowledge and skills that will be used often later. If I'm looking at a problem in an area that I will unlikely ever need to look at again, I tend to ask for help sooner 'cause I know the knowledge I acquire here will likely just be used once. But if it's an area I know I will need to solve problems in again, I spend as much time as I can to understand it.

- if I have an urgent problem and there's someone I know who will mostly likely know the answer right off the bat I would ask them for help sooner. And if it's something I think I'll need to know later I will then spend time to understand more details after I get the problem taken care of first ('cause other teams might be waiting on a solution). When I do ask for help, I give the other person a detailed description of the problem and details of all the debugging I've done so far, to save them time to ask for this info.

If you are someone who's a user of the GC, spending a lot of time knowing the nitty gritty details of the GC is probably not the best use of your time; but if you are responsible for analyzing the performance of the product you work on, spending time to learn a few fundamentals of memory and how to do memory analysis benefits immensely â€“ it will give you a lot of autonomy and having autonomy is a great thing ğŸ˜ƒ

### Continuing the analysis

In [Part 0](https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-0/) I mentioned I usually request 2 traces to start the investigation. The 2nd trace is to get CPU samples and some other general events like disk/network IO too:

<span style = "color:red">PerfView /nogui /accepteula /KernelEvents=default+Memory+VirtualAlloc /ClrEvents:GC+Stack /MaxCollectSec:600 /BufferSize:3000 /CircularMB:3000 collect</span>

The 1st trace, which is a GCCollectOnly trace, is to get an accurate idea about the GC perf â€“ you want to do this with absolute minimal interference and the GCCollectOnly commandline arg gives you exactly that. This 2nd trace gives you an idea how things are generally running on the machine. GC lives in a process and threads from that process and other processes can affect how GC runs. Note that currently there's no equivalent of this in dotnet-trace â€“ you would need to collect a trace on Linux with the [perfcollect](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/linux-performance-tracing.md#preparing-your-machine) script which uses perf+Lttng and unfortunately does not provide the exact equivalent (Lttng has no stacks) but otherwise does give you machine wide view instead of only events from one process that dotnet-trace gives you.

Notice that I'm also specifying the <span style = "color:red">/BufferSize:3000 /CircularMB:3000</span> args since we are now collecting a lot more events and the default may not be enough. For GCCollectOnly since we know it doesn't collect many events the default is enough. In general I've found 3000MB is enough for both args for this trace. If thereâ€™s a problem with these sizes, PerfView gives very informative messages so please pay attention to the dialogboxes it pops up! This is handled by the HandleLostEvents method:

``` java
private void HandleLostEvents(Window parentWindow, bool truncated, int numberOfLostEvents, int eventCountAtTrucation, StatusBar worker)
{
    string warning;
    if (!truncated)
    {
        // TODO see if we can get the buffer size out of the ETL file to give a good number in the message. 
        warning = "WARNING: There were " + numberOfLostEvents + " lost events in the trace.\r\n" +
            "Some analysis might be invalid.\r\n" +
            "Use /InMemoryCircularBuffer or /BufferSize:1024 to avoid this in future traces.";
    }
    else
    {
        warning = "WARNING: The ETLX file was truncated at " + eventCountAtTrucation + " events.\r\n" +
            "This is to keep the ETLX file size under 4GB, however all rundown events are processed.\r\n" +
            "Use /SkipMSec:XXX after clearing the cache (File->Clear Temp Files) to see the later parts of the file.\r\n" +
            "See log for more details.";
    }

```



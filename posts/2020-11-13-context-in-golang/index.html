<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-cn lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.85.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Go中的Context &#183; Tomato Punk</title><meta name=description content><link type=text/css rel=stylesheet href=https://murph.site/css/print.css media=print><link type=text/css rel=stylesheet href=https://murph.site/css/poole.css><link type=text/css rel=stylesheet href=https://murph.site/css/syntax.css><link type=text/css rel=stylesheet href=https://murph.site/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body class=theme-base-0c><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://murph.site/><h1>Tomato Punk</h1></a><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://murph.site/>Home</a></li><li><a href=https://github.com/tomatopunk/>Github</a></li><li><a href=lion.zhang@mail.com>Mail</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Go中的Context</h1><time datetime=2020-09-22T14:27:26Z class=post-date>Tue, Sep 22, 2020</time><h3 id=原文信息>原文信息</h3><p><a href=https://levelup.gitconnected.com/@ricardo.linck>@ricardo.linck</a>
<a href=https://levelup.gitconnected.com/context-in-golang-98908f042a57>原文:Context in Golang!</a></p><hr><p>Golang应用程序使用Contexts来进行控制与管理非常关健的应用可靠性,例如在<a href=https://levelup.gitconnected.com/goroutines-and-channels-concurrent-programming-in-go-9f9f8495c34d>concurrent programming</a>中的数据共享与取消.这听起来似乎很琐碎,但实际并非如此.在Golang中Contexts的入口点是<code>context</code>包.它非常有用,并且可能是整个语言功能最多的包之一.如果您还没有遇到任何有关上下文之类的东西,您大概很快就会遇到(或者您只是没有注意到它).上下文的用法非常广泛,以至于多数软件包都依赖它,并也假设您也会这样做.它绝对是Golang生态系统中的一个关键组件.</p><p>这里是<code>context</code>软件包的官方文档 <a href=https://golang.org/pkg/context/>https://golang.org/pkg/context/</a>.它真的很棒,并且包含了很多例子.为了尝试拓展它们,来让我们看看我在真实场景是如何使用的.</p><h3 id=使用上下文来包含您的数据>使用上下文来包含您的数据</h3><p>一个常见的使用上下文的用户之一是用于共享数据,或者使用请求作用域的值.当您有多个函数并且想在他们之间共享数据,您可以使用上下文.</p><p>最简单的方法是使用函数 context.WithValue.这个函数会根据父上下文创建一个新的上下文,并对您指定的Key添加一个值.您可以把内部实现看做是上下文的内部是一个map.</p><p>所以您可以添加或者使用Key来找回Values,这是非常强大的,因为它允许您在上下文内部存储任何类型的数据.</p><p>下面是一个用上下文添加和找回数据的例子.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;context&#34;</span>
	<span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
	<span style=color:#a6e22e>ctx</span> = <span style=color:#a6e22e>addValue</span>(<span style=color:#a6e22e>ctx</span>)
	<span style=color:#a6e22e>readValue</span>(<span style=color:#a6e22e>ctx</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addValue</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;key&#34;</span>, <span style=color:#e6db74>&#34;test-value&#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>readValue</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) {
	<span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Value</span>(<span style=color:#e6db74>&#34;key&#34;</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>val</span>)
}
</code></pre></div><blockquote><p>在上下文中添加和找回值</p></blockquote><p>在Context包设计背后有一种重要的方面,任何操作都会返回一个新的context.Context结构.这意味着您需要记住运行时要用带的返回值,并尽可能的使用新的上下文覆盖旧上下文.</p><p>这是来自于不可更改性(immutability)的关键设计.如果您想了解更多的关于gokang中的不可更改性,您可以阅读我的<a href=https://levelup.gitconnected.com/immutability-in-golang-7a13199060bb>这篇文章</a></p><p>要创建一个带有取消功能的上下文,您只需要使用函数<code>context.WithCancel(ctx)</code>将您的上下文通过参数传递进去.这会返回一个新的上下文与一个取消函数.您只需要调用取消函数,就可以取消上下文.</p><p>下面这个例子来自于<a href=https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577>对冲请求(Hedged Request)</a>实现的带有取消功能的上下文.来让我们快速的回顾一下<a href=https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577>对冲请求(Hedged Request)</a>:我们对一个外部服务发起请求,如果在我们定义的时间没有返回,我们会发出第二个请求.当请求返回了,所有其他的请求都会被取消掉.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;context&#34;</span>
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;io/ioutil&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#a6e22e>neturl</span> <span style=color:#e6db74>&#34;net/url&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>queryWithHedgedRequestsWithContext</span>(<span style=color:#a6e22e>urls</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, len(<span style=color:#a6e22e>urls</span>))
	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>url</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>urls</span> {
		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>u</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>c</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>) {
			<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>executeQueryWithContext</span>(<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>ctx</span>)
		}(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>ch</span>)

		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>:
			<span style=color:#a6e22e>cancel</span>()
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>After</span>(<span style=color:#ae81ff>21</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>):
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>executeQueryWithContext</span>(<span style=color:#a6e22e>url</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>parsedURL</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>neturl</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>url</span>)
	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>{<span style=color:#a6e22e>URL</span>: <span style=color:#a6e22e>parsedURL</span>}
	<span style=color:#a6e22e>req</span> = <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>ctx</span>)

	<span style=color:#a6e22e>response</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>req</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>()
	}

	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>Body</span>.<span style=color:#a6e22e>Close</span>()
	<span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>Body</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Request time: %d ms from url%s\n&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>start</span>).<span style=color:#a6e22e>Nanoseconds</span>()<span style=color:#f92672>/</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>.<span style=color:#a6e22e>Nanoseconds</span>(), <span style=color:#a6e22e>url</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s from %s&#34;</span>, <span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>url</span>)
}
</code></pre></div><p>每个请求都是在一个独立的go routine中触发的.这个上下文被传递给所有触发的请求.唯一的逻辑就是将上下文传播给Http client.以便当取消函数辈调用时,可以优雅的取消请求和底层连接.对于接受context.Context作为参数的函数来说,这是一个非常常见的模式,它们要么主动地对上下文采取行动(比如检查它们是否已经取消),要么将它们传递给处理它的底层函数(本例中是通过http.Request的Do函数接受上下文)</p><h3 id=超时上下文>超时上下文</h3><p>在处理外部请求时,超时是一种非常常见的模式,类似通过Http或gRPC查询数据库或者从其他服务中获取数据.使用Context包处理这些产经非常简单.您所需要做的就是调用函数<code>context.WithTimeout(ctx,time)</code>,传递您的上下文与实际的超时时间,类似这样</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</code></pre></div><p>您仍然可以接受到取消函数,以防您想手动触发它.它的工作方式与普通的超时上下文相同.</p><blockquote><p>一个好做法是,使用defer调用取消函数,避免内存泄露</p></blockquote><p>这个例子的行为非常直接.如果超时了,上下文会被取消.在HTTP调用的情况下,它的工作原理与上面的例子基本相同</p><h3 id=grpc>gRPC</h3><p>Context是gRPC在golang的实现中的一个基本部分.它即用来共享数据(如何取消<a href=https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md>元数据</a>)也用来控制流量,类似于取消流或请求.这是我的两个例子,来自于<a href=https://github.com/RicardoLinck/grpc-go>GitHub存储库</a>.</p><h4 id=metadata>Metadata</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>) <span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>calculatorpb</span>.<span style=color:#a6e22e>SumRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>calculatorpb</span>.<span style=color:#a6e22e>SumResponse</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Sum rpc invoked with req: %v\n&#34;</span>, <span style=color:#a6e22e>req</span>)
	<span style=color:#a6e22e>md</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>metadata</span>.<span style=color:#a6e22e>FromIncomingContext</span>(<span style=color:#a6e22e>ctx</span>)
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Metadata received: %v&#34;</span>, <span style=color:#a6e22e>md</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>calculatorpb</span>.<span style=color:#a6e22e>SumResponse</span>{
		<span style=color:#a6e22e>Result</span>: <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>NumA</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>NumB</span>,
	}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><blockquote><p>Server implementation receiving metadata</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>calculatorpb</span>.<span style=color:#a6e22e>CalculatorServiceClient</span>) {
	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>calculatorpb</span>.<span style=color:#a6e22e>SumRequest</span>{
		<span style=color:#a6e22e>NumA</span>: <span style=color:#ae81ff>3</span>,
		<span style=color:#a6e22e>NumB</span>: <span style=color:#ae81ff>10</span>,
	}
	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>metadata</span>.<span style=color:#a6e22e>AppendToOutgoingContext</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#e6db74>&#34;user&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>)
	<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>req</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Error calling Sum RPC: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Response: %d\n&#34;</span>, <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>Result</span>)
}
</code></pre></div><blockquote><p>Client implementation sending metadata</p></blockquote><h4 id=calcellation>Calcellation:</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>) <span style=color:#a6e22e>Greet</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>greetpb</span>.<span style=color:#a6e22e>GreetRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>greetpb</span>.<span style=color:#a6e22e>GreetResponse</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Greet rpc invoked!&#34;</span>)

	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>500</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Canceled</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>status</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>codes</span>.<span style=color:#a6e22e>Canceled</span>, <span style=color:#e6db74>&#34;Client cancelled the request&#34;</span>)
	}

	<span style=color:#a6e22e>first</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Greeting</span>.<span style=color:#a6e22e>FirstName</span>
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>greetpb</span>.<span style=color:#a6e22e>GreetResponse</span>{
		<span style=color:#a6e22e>Result</span>: <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Hello %s&#34;</span>, <span style=color:#a6e22e>first</span>),
	}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><blockquote><p>Server implementation handling context cancellation</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>greetWithTimeout</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>greetpb</span>.<span style=color:#a6e22e>GreetServiceClient</span>) {
	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>greetpb</span>.<span style=color:#a6e22e>GreetRequest</span>{
		<span style=color:#a6e22e>Greeting</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>greetpb</span>.<span style=color:#a6e22e>Greeting</span>{
			<span style=color:#a6e22e>FirstName</span>: <span style=color:#e6db74>&#34;Ricardo&#34;</span>,
			<span style=color:#a6e22e>LastName</span>:  <span style=color:#e6db74>&#34;Linck&#34;</span>,
		},
	}
	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()
	<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Greet</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>req</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>grpcErr</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>status</span>.<span style=color:#a6e22e>FromError</span>(<span style=color:#a6e22e>err</span>)

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>grpcErr</span>.<span style=color:#a6e22e>Code</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>codes</span>.<span style=color:#a6e22e>DeadlineExceeded</span> {
				<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;Deadline Exceeded&#34;</span>)
			}
		}

		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Error calling Greet RPC: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Response: %s\n&#34;</span>, <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>Result</span>)
}
</code></pre></div><h3 id=opentelemetry>OpenTelemetry</h3><p><code>OpenTelemetry </code>还严重依赖于上下文来实现所谓的<strong>上下文传播(Context Propagation)</strong>.这是一种将不同系统中请求捆绑起来的做法.实现方式是将Span信息<code>注入(Inject)</code>到上下文中,作为您使用的协议的一部分(例如HTTP或gRPC).在另一个服务上,您需要<code>提取(Extrace)</code>Span信息.我在两篇文章中写过关于OpenTelemetry的文章,您可以在之类找到<a href=https://medium.com/swlh/distributed-tracing-with-opentelemetry-part-1-6719df95a364>part 1</a>,<a href=https://levelup.gitconnected.com/distributed-tracing-with-opentelemetry-part-2-cc5a9a8aa88c>part 2</a>.在这里您可以找到更多的关于OpenTelemetry的信息,以及使用gRPC和HTTP的例子.</p><h3 id=最后的一些想法>最后的一些想法</h3><p>上下文是作为Golang基本特性的一部分.因此理解并知道如何使用它们是非常重要的.<code>Context</code>包提供了一个非常简单和轻量级的API来与这个关键组件进行交互.关于<code>context.Context</code>的另一个重要的事情是,它可以用于多种事情.我们再这篇文章中涉及到了很多场景,在其中一些场景中,一个单一的上下文可以用来控制和携带范围值.这使得上下文成为创建可靠和简单代码的一个非常重要和强大的工具.</p></div></main></body></html>
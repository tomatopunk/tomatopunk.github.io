<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>诊断性能问题的工作流程(1) - TomatoPunk</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="murphy"><meta name=description content="原文为Maoni发布在Microfost Blog中的, 诊断性能问题的工作流程系列. 目前共更新三章. 在本章中, Maoni介绍了一些在进行性能诊"><meta name=generator content="Hugo 0.85.0"><link rel=canonical href=https://murph.site/post/2020-05-06-diagnosingmemoryperformance-part1/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css integrity="sha256-+ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media=screen crossorigin=anonymous><meta property="og:title" content="诊断性能问题的工作流程(1)"><meta property="og:description" content="原文为Maoni发布在Microfost Blog中的, 诊断性能问题的工作流程系列. 目前共更新三章. 在本章中, Maoni介绍了一些在进行性能诊"><meta property="og:type" content="article"><meta property="og:url" content="https://murph.site/post/2020-05-06-diagnosingmemoryperformance-part1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-05-06T14:27:26+00:00"><meta property="article:modified_time" content="2020-05-06T14:27:26+00:00"><meta itemprop=name content="诊断性能问题的工作流程(1)"><meta itemprop=description content="原文为Maoni发布在Microfost Blog中的, 诊断性能问题的工作流程系列. 目前共更新三章. 在本章中, Maoni介绍了一些在进行性能诊"><meta itemprop=datePublished content="2020-05-06T14:27:26+00:00"><meta itemprop=dateModified content="2020-05-06T14:27:26+00:00"><meta itemprop=wordCount content="5176"><meta itemprop=keywords content="C#,Maoni,PerfView,"><meta name=twitter:card content="summary"><meta name=twitter:title content="诊断性能问题的工作流程(1)"><meta name=twitter:description content="原文为Maoni发布在Microfost Blog中的, 诊断性能问题的工作流程系列. 目前共更新三章. 在本章中, Maoni介绍了一些在进行性能诊"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-9F0K81DG4J','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>TomatoPunk</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://murph.site/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://murph.site/tags/>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://murph.site/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://murph.site/about>About</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://murph.site/about/>About Me</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>TomatoPunk</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://murph.site/>Home</a></li><li class=menu-item><a class=menu-item-link href=https://murph.site/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=https://murph.site/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=https://murph.site/about>About</a></li><li class=menu-item><a class=menu-item-link href=https://murph.site/about/>About Me</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>诊断性能问题的工作流程(1)</h1><div class=post-meta><time datetime=2020-05-06 class=post-time>2020-05-06</time><div class=post-category><a href=https://murph.site/categories/index/>Index</a></div><span class=more-meta>5176 words</span>
<span class=more-meta>11 min read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Table of Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#原文信息>原文信息</a></li><li><a href=#正文>正文</a><ul><li><a href=#继续分析>继续分析</a></li><li><a href=#继续分析-1>继续分析</a></li></ul></li></ul></nav></div></div><div class=post-content><p>原文为Maoni发布在Microfost Blog中的, 诊断性能问题的工作流程系列.
目前共更新三章. 在本章中, Maoni介绍了一些在进行性能诊断时的操作与分析.</p><h2 id=原文信息>原文信息</h2><ul><li><a href=https://twitter.com/maoni0>@Maoni Stephens-Twitter</a></li><li><a href=https://github.com/Maoni0>@Maoni Stephens-Github</a></li></ul><p><img src=/posts/images/1587561145552-0d8a560c-3b7d-443a-badc-a98ddbb6e7bf.png alt=authorize></p><p>如果这篇文章可以帮到您，那么这将是我最大的荣幸，希望您点进原文，在文章下方留下善意的回复，您的支持将是这些可敬的社区磐石保持创作激情中最大的一部分:)</p><p><a href=https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-1>原文</a></p><p><strong>中文版本将不会以任何形式收费，版权属与原作者</strong></p><hr><h2 id=正文>正文</h2><p>在此篇文章中, 我会讨论一些关于怎样对PerfView做出贡献的内容, 然后继续分析GCStats. 您可以直接<a href=https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-1/#continuing-the-analysis>跳到分析部分</a>.</p><p>对于分析工具, 有一点令我沮丧, 市面上有很多的内存性能工具, 但很少有针对可通用类型以及与我所服务的客户的. 所有的工具都很基础, 很少有工具能进行中级和高级分析.</p><p>我知道有很多人在抱怨PerfView的可用性 - 我确实赞同一些抱怨. 但尽管如此, 我还是喜欢PerfView, 因为这是它往往是我唯一一个能用来完成工作的工具.</p><p>我希望大家能够理解</p><ol><li>我能放在PerfView上的精力非常有限. 我没有类似Visual Studio组织完整的工作团队;我只有部分时间, 来自于少部分成员的兼职, 所以很难满足所有用户的要求.</li><li>在进行高级分析时, 情况会变得非常复杂, 这意味着实现可用性没有那么简单-当有很多需要关注的细节时, permutation很快会变得十分庞大.</li></ol><p>对类似PerfView之类的项目做出贡献, 是对<code>. NET Core</code>做出贡献的绝佳方式, 它没有运行时本身那么陡峭的学习曲线, 但是您的贡献可能会帮助人们节省大量时间.</p><p>您可以从克隆<a href=https://github.com/microsoft/perfview/>Perfview repo</a>并编译它开始. 然后您可以通过单步执行代码来学习了 – IMO 单步执行代码, 这往往是最好的了解新鲜事物的方法.</p><p>我在此讨论内容的代码大部分都位于2个文件中</p><pre><code>- src\TraceEvent\Computers\TraceManagedProcess. cs 
- src\PerfView\GCStats. cs.  
</code></pre><p>如果您搜索诸如Clr. EventName(例如Clr. GCStart与Clr. GCStop), 这里就是进行事件分析的地方(您不需要关心对于跟踪的解析 – 那在其他地方处理的).</p><p>对于GC的分析就是这个文件中的<a href=https://devblogs.microsoft.com/dotnet/glad-part-2/>GLAD</a> (GC Latency Analysis and Diagnostics)库. GCStats. cs使用它来显示您在GCStats视图中看到的东西, 它是一个HTML文件. 如果您想在自己的工具上展示GC的相关信息, GCStats. cs是一个很好的使用GLAD的例子.</p><h3 id=继续分析>继续分析</h3><p>该篇包含两部分内容. 怎样对PerfView进行贡献, 然后我会继续分析 GCStats. 您也可以直接跳转到 <a href=#>分析部分</a>(<a href=https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-1/#continuing-the-analysis)>https://devblogs.microsoft.com/dotnet/work-flow-of-diagnosing-memory-performance-issues-part-1/#continuing-the-analysis)</a>.</p><p>虽然有许许多多的分析内存性能的工具, 能让我和我的客户完成大多数工作的的却很少. 每个工具都很基础, 无法进行中级和高级的分析.</p><p>我知道有很多人认为 PerfView 难以使用 - 我赞同其中的一些观点. 但尽管如此, 我还是喜欢PerfView. 往往我只能使用它来完成工作.</p><p>希望大家能理解: 1) 我能放在 PerfView 项目上的精力非常有限. 我们没有类似 Visual Studio 这样完整的团队; 只有少部分成员的兼职, 所以很难满足所有用户的要求. 2) 在进行高级分析时, 情况往往非常复杂, 当有如此多的可能性, 列表会快速地变大.</p><p>对类似PerfView的项目进行贡献, 也是对 <code>.Net Core</code> 做出贡献的绝佳方式, 该项目没有运行时陡峭的学习曲线, 但是您的贡献会帮助人们节省大量时间. 您可以从克隆<a href=#>Perfview repo</a>(<a href=https://github.com/microsoft/perfview/>https://github.com/microsoft/perfview/</a>)并编译它开始. 然后您可以通过单步执行代码进行学习.</p><blockquote><p>在我看来, 单步执行代码, 这总是理解新事物的最好方法.</p></blockquote><p>我在此处讨论内容的相关代码大部分都位于2个文件中. srcTraceEventComputersTraceManagedProcess.cs 和 srcPerfViewGCStats.cs.</p><p>如果您搜索Clr.EventName (例如Clr.GCStart与Clr.GCStop) . 此处就是进行事件分析的地方 (您不需要关心对于跟踪的解析, 那是在其他地方处理的). 对于GC的分析就是这个文件中的<a href=#>GLAD</a>(<a href=https://devblogs.microsoft.com/dotnet/glad-part-2/>https://devblogs.microsoft.com/dotnet/glad-part-2/</a>) (GC Latency Analysis and Diagnostics)库. GCStats.cs 使用它来显示您在 GCStats 视图, 这是一个 HTML 文件. 如果您想在自己的工具上展示 GC 的相关信息, GCStats.cs 是一个很好的使用 GLAD 的例子.</p><h3 id=继续分析-1>继续分析</h3><p>上一篇文章中, 我们谈到了收集 GCCollectOnly 跟踪和检查 PerfView 中的GCStats视图, 该视图由收集的 GC 事件启用. 您也可以在 Linux 上用 dotnet-trace 做这件事. 从它的<a href=https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md>文档</a>中可以看出: 它提供的一个内置配置文件相当于 PerfView 的收集命令中的 <code>/GCCollectOnly</code> 参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-Shell data-lang=Shell> --profile

   <span class=o>[</span>omitted<span class=o>]</span>

   gc-collect   以极低的性能开销仅跟踪收集GC
</code></pre></td></tr></table></div></div><p>您可以使用dotnet-trace命令, 在Linux上收集跟踪信息.</p><p>** dotnet trace collect -p &lt;pid> -o &lt;outputpath> &ndash;profile gc-collect**</p><p>并在 Windows 上用 PerfView 查看. 从使用者的角度看, 当您查看 GCStats 视图时, 两者唯一的区别是, 在 Windows 上收集的跟踪, 您会看到所有的托管线程, 而在 Linux 上收集的跟踪只有您指定的pid的进程.</p><p>在这篇博文中, 我将重点介绍您在 GCStats 中看到的表格. 我在这里展示一个例子. 一个进程的第一个表是 &ldquo;GC Rollup By Generation &ldquo;表 &ndash;</p><p><img src=# alt=WorkFlow-GCRollupByGeneration>(/posts/images/WorkFlow-GCRollupByGeneration.png)</p><p>我省略了 <code>Alloc MB/MSec GC</code> 与 <code>Survived MB/MSec GC</code> 这两列 – 他们在我开始研究PerfView之前就已经存在了, 如果能把它们修复得更有意义就好了, 但我一直没有处理.</p><p>现在, 如果您在做一个日常性分析, 也就是说您没有一个直接的目标, 只是想看看是否有什么需要改进的地方, 您可以从这个滚动表开始.</p><p>如果我们查看上面的表格, 就会发现 gen2 的平均中断时间比 gen0/1 的 GCs 大很多. 我会猜测 gen2 可能没有经历过中断, 因为<code>Max Peak MB</code> 大约是13GB，如果我们要遍历所有这些内存, 大概要花费超过167ms. 所以这些很可能是BGCs (Background GC), 这一点在滚动表下面的 &ldquo;Gen 2 for pid: process_name &ldquo;表中得到了证实（我从表中删除了一些列，这样就不会太宽了） -_</p><p><img src=# alt=WorkFlow-GCRollupByGeneration2>(/posts/images/WorkFlow-GCRollupByGeneration2.png)</p><p>2B表示在后台执行的二代堆GC. 如果您想知道还有哪些组合, 只需将鼠标悬停在"Gen"的列标题上, 将显示以下文字:</p><p>** N=NonConcurrent/非并发式GC, B=Background/后台GC, F=Foreground/前台GC (一直以后台GC运行) I=Induced/触发式GC i=InducedNotForced/触发非前台 **</p><ul><li>N=NonConcurrent/非并发式GC</li><li>B=Background/后台GC</li><li>F=Foreground/前台GC (一直以后台GC运行)</li><li>I=Induced/触发式GC</li><li>i=InducedNotForced/触发非前台</li></ul><p>所以对于<code>二代堆GC</code>, 您可能会看到2N, 2NI, 2Ni or 2Bi. 如果您使用GC. Collect来触发GC, 它有两个采用此参数的重载 –</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cs data-lang=cs><span class=p>(</span><span class=kt>bool</span> <span class=n>blocking</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>除非您将该参数指定为False, 它意味着将始终以阻塞的方式触发GC. 这就是为什么没有2BI的原因</p><p>在rollup表中, 始终有一列<code>Induced</code>显示为0 , 但如果这不是0, 特别是当与GC的总数相比时是一个相当大的数字时, 找出是谁在触发这些GC是一个非常好的主意. 这在这篇<a href=#>博客</a>(<a href=https://devblogs.microsoft.com/dotnet/gc-etw-events-2/>https://devblogs.microsoft.com/dotnet/gc-etw-events-2/</a>)中做了详细的讲解.</p><p>所以, 我知道了这些GC总数全部来源于BGC, 但是, 对于BGC来说, 这些中断的时间太长了!</p><p>请注意, 虽然我将两次中断显示成了一次, 但它实际是由两次中断组成的. 在<a href=#>这张来自GC MSDN的图片</a>(<a href=https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/media/fundamentals/background-workstation-garbage-collection.png>https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/media/fundamentals/background-workstation-garbage-collection.png</a>)中, 显示了一次BGC中的两次中断(蓝色的列所指的位置).</p><p>但是, 您在GCStats中看到的中断时间是这两次中断的总和. 原因是最早地中断通常都非常短(图片中的蓝色列仅用于举例-它们并不代表实际上真正用了多长时间). 在这种情况下, 我想看每个单独地中断花费了多长时间 - 我正在考虑在GLAD中提供各个BGC的中断信息, 但在这之前, 您可以自己弄清楚.</p><p>在<a href=#>这篇博客中</a>(<a href=https://devblogs.microsoft.com/dotnet/gc-etw-events-3/),>https://devblogs.microsoft.com/dotnet/gc-etw-events-3/),</a> 我描述了BGC在触发事件时的顺序. 所以我需要找到两次<code>SuspendEE/RestartEE</code>事件.</p><p>要做到这一点, 您可以在PerfView中打开<code>“Events”</code>视图, 然后从<code>“Pause Start”</code>开始.</p><p>让我以GC#9217为例, 它的首次中断在789, 274. 32 您可以在“Start”输入框中输入它. 然后在“Process Filter”中输入“gc/”, 仅过滤GC事件, 然后选择SuspendEE/RestartEE/GCStart/GCStop事件, 摁下回车.</p><p>下面是此时您将会看到的示例图片(出于隐私原因, 我删除了进程名字) -
<img src=# alt=WorkFlow1-0>(/posts/images/WorkFlow1-0.jpg)</p><p>这就是首次发生中断的地方, 如果您选择首次SuspendEEStart和首次RestartEEStop的时间戳, 我可以看到在这个视图的状态栏上显示了两个时间戳的差异是75. 902. 这已经非常长了 -通常来说, 首次中断时间每组都应当不超过几毫秒. 对于这种情况, 您基本上可以将其交给我, 因为在我的设计中, 不应该出现这种情况.</p><p>但是, 如果您有兴趣自己继续诊断, 下一步是捕获更多的事件跟踪, 来向我展示挂起期间发生了什么. 通常, 我捕获的跟踪是CPU事件样本+GC的事件跟踪. CPU样本清楚的向我展示了真正的罪魁祸首. 其实并不是在GC中, 而是运行时中的其他东西. 后来我已经修复了, 这个性能问题只有在您的程序中有多个模块时才会发生(在这个特殊的场景下, 客户拥有数千个模块).</p><p>第二次的BGC中断从SuspendEEStart事件, 原因是“SuspendForGCPrep”, 与第一次的SuspendEESrart事件不同的是, 此次原因是“SuspendForGC”.</p><p>由GC为目的引发的停顿, 仅有两个可能, 而“SuspendForGCPrep”仅在初次中断的BGC期间可用.</p><p>通常来说, 一个BGC仅会有两次中断, 但如果您启用了<code>GCHeapSurvivalAndMovementKeyword</code>事件, 您将在BGC期间添加第三个中断, 因为要触发这些事件, 托管线程必须处于中断状态. 如果是这种情况, 第三次暂停也会有“SuspendForGCPerp”原因, 并且通常比其他两个中断要长的多. 因为堆如果很大, 触发事件将花费很长的时间.</p><p>我见过很多这种情况, 当大家根本不需要这些事件时, 却看到BGC的中断时间被人为拉长. 原因正是这个.</p><p>您可能会问, 既然不需要这些事件, 为什么还会不小心的收集到这些事件. 这是因为您在收集运行时事件时, 它们已经包含在默认值中(您可以在srcTraceEventParsersClrTraceEventParser.cs 中看到默认值中包含的关键字, 搜索default. 您会看到许多关键字被包含在了默认值中).</p><p>一般来说, 我认为PerfView的理念是, 默认情况下应当收集足够的事件提供给您以便进行调查. 在一般情况下, 这都是一个很好的策略, 因为您可能无法对问题进行复现. 但是您需要通过收集事件本身来判断, 什么是由于收集事件引发的, 什么是由于产品引发的.</p><p>当然, 这是在建立在您有能力收集这么多事件的基础上. 有时绝对不是这种情况. 这就是为什么我通常要求人们从轻量级跟踪开始, 来向我表明这里是否存在问题, 以及如果存在问题, 我还需要收集哪些事件.</p><p>我从gen2表注意到了的另一件事, 所有的BGC都是由AllocLarge触发的. 可能被触发的原因定义为GCReason:</p><ul><li><a href=#>srcTraceEventParsersClrTraceEventParser.cs</a>(<a href=https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Parsers/ClrTraceEventParser.cs>https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Parsers/ClrTraceEventParser.cs</a>)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cs data-lang=cs><span class=k>public</span> <span class=k>enum</span> <span class=n>GCReason</span>
<span class=p>{</span>
    <span class=n>AllocSmall</span> <span class=p>=</span> <span class=m>0x0</span><span class=p>,</span> 
    <span class=n>Induced</span> <span class=p>=</span> <span class=m>0x1</span><span class=p>,</span> 
    <span class=n>LowMemory</span> <span class=p>=</span> <span class=m>0x2</span><span class=p>,</span> 
    <span class=n>Empty</span> <span class=p>=</span> <span class=m>0x3</span><span class=p>,</span> 
    <span class=n>AllocLarge</span> <span class=p>=</span> <span class=m>0x4</span><span class=p>,</span> 
    <span class=n>OutOfSpaceSOH</span> <span class=p>=</span> <span class=m>0x5</span><span class=p>,</span> 
    <span class=n>OutOfSpaceLOH</span> <span class=p>=</span> <span class=m>0x6</span><span class=p>,</span> 
    <span class=n>InducedNotForced</span> <span class=p>=</span> <span class=m>0x7</span><span class=p>,</span> 
    <span class=n>Internal</span> <span class=p>=</span> <span class=m>0x8</span><span class=p>,</span> 
    <span class=n>InducedLowMemory</span> <span class=p>=</span> <span class=m>0x9</span><span class=p>,</span> 
    <span class=n>InducedCompacting</span> <span class=p>=</span> <span class=m>0xa</span><span class=p>,</span> 
    <span class=n>LowMemoryHost</span> <span class=p>=</span> <span class=m>0xb</span><span class=p>,</span> 
    <span class=n>PMFullGC</span> <span class=p>=</span> <span class=m>0xc</span><span class=p>,</span> 
    <span class=n>LowMemoryHostBlocking</span> <span class=p>=</span> <span class=m>0xd</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>最常见的原因是<code>AllocSmall</code>, 意味着您在<code>SOH(Small Object Heap)</code>的分配触发了GC. 而<code>AllocLarge</code>意味着<code>LOH(Long Object Heap)</code>的分配触发了GC.</p><p>在这种特殊下团队已经意识到, 他们正在进行大量的LOH分配 – 但他们可能不知道会经常导致BGC.</p><p>如果您查看“Gen2 Survival Rate %”列, 您会注意到二代的存活率非常高(97%), 但是“LOH Survival Rate %(LOH存活率 %)”却非常低-29%</p><p>这告诉了我, 有许多的LOH分配存活的相当短. 我会根据gen2的预算调整LOH的预算(分配量阈值), 因此在这种情况下, 我不会过多的触发gen2的GC.</p><p>如果我想提高LOH的存活率, 我需要比这更加频繁地触发BGC. 如果您很清楚您的LOH的分配通常是临时的, 那么通过GCLOHThreshold的配置增大LOH的阈值就是一个不错的办法.</p><p>这就是今天的全部内容了. 下次我将讨论GCStats视图中更多表.</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>murphy</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2020-05-06</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=https://murph.site/tags/c#/>C#</a>
<a href=https://murph.site/tags/maoni/>Maoni</a>
<a href=https://murph.site/tags/perfview/>PerfView</a></div><nav class=post-nav><a class=prev href=/post/2020-05-07-diagnosingmemoryperformance-part2/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">诊断性能问题的工作流程(2)</span>
<span class="prev-text nav-mobile">Prev</span></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:lion.zhang@mail.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg></a><a href=https://github.com/tomatopunk rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=https://murph.site/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2015 -
2022
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>京ICP备2020037990号</span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script><script type=text/javascript src=/js/load-photoswipe.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>